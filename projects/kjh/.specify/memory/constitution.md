<!--
═══════════════════════════════════════════════════════════════════════════════
동기화 영향 보고서
═══════════════════════════════════════════════════════════════════════════════
버전 변경: [미버전] → 1.0.0

수정된 원칙:
- 신규: I. 커널 우선 아키텍처 (eBPF 데이터 플레인)
- 신규: II. 메모리 안전성 (Rust 사용자 공간)
- 신규: III. CO-RE 이식성
- 신규: IV. Verifier 준수 (타협 불가)
- 신규: V. 저지연 성능
- 신규: VI. 엄격한 플레인 분리

추가된 섹션:
- 보안 및 RBAC 요구사항
- 개발 워크플로우 및 품질 게이트

제거된 섹션: 없음 (최초 생성)

업데이트가 필요한 템플릿:
- ✅ .specify/templates/plan-template.md - Constitution Check 섹션에서 eBPF/Rust 원칙 강제 필요
- ✅ .specify/templates/spec-template.md - 기능 요구사항에 지연시간/보안 메트릭 포함 필요
- ✅ .specify/templates/tasks-template.md - 태스크 단계에서 eBPF 컴파일 + 사용자 공간 데몬 패턴 반영 필요
- ✅ .specify/templates/agent-file-template.md - 업데이트 불필요 (일반적 구조)

후속 TODO: 없음

MAJOR (1.0.0) 버전 증가 근거:
- 핵심 프로젝트 거버넌스를 수립하는 최초 헌장 비준
═══════════════════════════════════════════════════════════════════════════════
-->

# IDP/RBAC VPN 라우터 헌장

## 핵심 원칙

### I. 커널 우선 아키텍처 (eBPF 데이터 플레인)

모든 패킷 처리, 라우팅 결정, 성능에 민감한 작업은 반드시 eBPF 프로그램을 통해 커널 데이터
플레인에서 실행되어야 합니다. 사용자 공간 컴포넌트는 제어 플레인 업무로 제한됩니다: 정책 관리,
설정 업데이트, 원격 측정 집계, IDP/RBAC 규칙 컴파일.

**근거**: 커널 공간 패킷 처리는 컨텍스트 스위치를 제거하고 마이크로초 이하의 지연 시간 목표를
달성합니다. 핫 패스(hot path)에서 사용자 공간 개입은 금지됩니다.

**요구사항**:
- XDP(eXpress Data Path) 프로그램이 인그레스 패킷 필터링 및 포워딩 처리
- TC(Traffic Control) eBPF 프로그램이 이그레스 정책 시행 관리
- 모든 라우팅 조회는 O(1) 또는 O(log n) 성능을 위해 eBPF 맵(LPM 트라이, 해시맵) 사용
- 정상 포워딩 작업 중 패킷 데이터가 사용자 공간으로 넘어가지 않음

### II. 메모리 안전성 (Rust 사용자 공간)

모든 사용자 공간 데몬, 제어 플레인 로직, 설정 파서, IDP/RBAC 정책 컴파일러는 반드시 Rust로
구현되어야 합니다. 메모리 안전하지 않은 언어(C/C++)는 불가피한 커널 인터페이스와의 FFI 경계를
제외하고 금지됩니다.

**근거**: VPN 라우터는 공격자에게 높은 가치의 타겟입니다. 제어 플레인 컴포넌트의 메모리 안전성
취약점은 정책 우회나 권한 상승으로 이어질 수 있습니다. Rust의 소유권 모델은 컴파일 타임에
전체 클래스의 CVE를 제거합니다.

**요구사항**:
- 안전한 eBPF 프로그램 로딩과 맵 상호작용을 위해 `libbpf-rs` 또는 `aya` 사용
- 명시적 보안 검토 및 문서화 없이 `unsafe` 블록 사용 금지
- CI/CD에 `cargo audit`를 통한 의존성 감사 통합
- 정책 파서와 설정 핸들러를 위한 퍼징 하네스 구축

### III. CO-RE 이식성 (Compile Once – Run Everywhere)

모든 eBPF 프로그램은 반드시 BTF(BPF Type Format)와 CO-RE(Compile Once – Run Everywhere)
재배치를 사용하여 재컴파일 없이 커널 버전 간 바이너리 이식성을 보장해야 합니다.

**근거**: Site-to-site VPN 배포는 다양한 커널 버전을 가진 이기종 환경(클라우드 VM, 온프레미스
서버, 엣지 디바이스)에 걸쳐 있습니다. 타겟별로 eBPF 프로그램을 재빌드하는 것은 운영상 불가능합니다.

**요구사항**:
- BTF 지원 커널(Linux 5.2+)에서 `libbpf` 또는 `libbpf-rs` 사용
- 하드코딩된 커널 구조체 오프셋 사용 금지; `bpf_core_read()` 및 CO-RE 헬퍼 사용
- 테스트 스위트는 최소 3개의 커널 버전(예: 5.10 LTS, 5.15 LTS, 6.1 LTS)에 대해 eBPF 프로그램 검증
- BTF 지원이 없는 커널에 대한 우아한 성능 저하 또는 명시적 오류 처리

### IV. Verifier 준수 (타협 불가)

모든 eBPF 프로그램은 복잡도 제한 무시나 verifier 해킹 없이 Linux 커널 verifier의 정적 분석
검사를 반드시 통과해야 합니다. 검증에 실패한 프로그램은 우회가 아닌 재설계되어야 합니다.

**근거**: Verifier는 메모리 안전성, 루프 종료, 제한된 실행 시간을 보장합니다. 이를 우회하면
커널 안정성 보장이 무효화되고 크래시 벡터가 생성됩니다.

**요구사항**:
- 최대 명령어 수 준수(Linux 5.13+ 기준 프로그램 경로당 1M 명령어)
- 동적 반복이 필요한 경우 증명 가능한 루프 경계 또는 루프 언롤링
- 무제한 재귀나 스택 오버플로우 금지
- 단일 프로그램 제한 초과 시 tail call을 통한 복잡도 예산 관리
- 거부된 프로그램에 대한 verifier 로그 검토 필수(CI 아티팩트에 저장)

### V. 저지연 성능

복잡한 정책 평가가 필요하지 않은 패킷의 포워딩 지연 시간은 반드시 10마이크로초(p99) 이하를
유지해야 합니다. 정책이 많은 플로우(예: 사용자별 RBAC 검사)는 50마이크로초(p99) 이내에
완료되어야 합니다.

**근거**: Site-to-site VPN 배포는 지연 시간에 민감한 환경(금융 트레이딩, 실시간 제어 시스템,
VoIP)에서 물리적 라우터를 대체합니다. 성능 저하는 사용자에게 가시적인 영향을 미칩니다.

**요구사항**:
- eBPF 맵 조회는 사전 계산된 해시 테이블 또는 LPM 트라이 사용(선형 스캔 금지)
- 정책 결정은 eBPF 맵에 캐시; 사용자 공간은 맵을 원자적으로 업데이트
- 원격 측정은 ringbuffer 또는 perf 이벤트 사용(핫 패스에서 동기 로깅 금지)
- `bpf_ktime_get_ns()`와 eBPF 맵의 히스토그램을 통한 지연 시간 추적
- 벤치마크 스위트는 10k pps와 1M pps 부하에서 p50/p95/p99 지연 시간 검증

### VI. 엄격한 플레인 분리

데이터 플레인(eBPF)과 제어 플레인(사용자 공간 데몬)은 반드시 eBPF 맵을 통해서만 통신해야
합니다. 공유 메모리, 소켓, 사이드 채널은 허용되지 않습니다.

**근거**: 깔끔한 분리는 독립적인 테스트, 장애 격리(제어 플레인 크래시가 패킷을 드롭하지 않음),
보안 경계(손상된 데몬이 패킷을 직접 조작할 수 없음)를 가능하게 합니다.

**요구사항**:
- eBPF 프로그램은 사용자 공간 응답을 기다리며 블록되지 않음
- 맵에 대한 사용자 공간 업데이트는 순서가 중요한 경우 원자적 연산 사용
- 맵 스키마는 버전 관리되고 검증됨(타입 불일치는 데몬 시작 실패 유발)
- 제어 플레인 재시작이 포워딩을 방해하지 않아야 함(맵은 데몬 생명주기를 넘어 지속)
- 상태 지속성을 위해 BPF 파일시스템(`/sys/fs/bpf/`)에 맵 피닝

## 보안 및 RBAC 요구사항

**Identity Provider(IDP) 통합**:
- 사용자 신원은 패킷 포워딩 결정 전에 RBAC 정책으로 해석되어야 함
- 사용자 공간 데몬을 통한 OIDC, SAML 또는 커스텀 IDP 통합 지원
- TTL 기반 만료와 함께 eBPF 맵에 신원-정책 매핑 캐시

**역할 기반 접근 제어(RBAC)**:
- 정책 정의: `{user_role, source_network, dest_network, protocol, action}`
- 선언적 YAML/JSON에서 eBPF 맵 항목으로 정책 컴파일
- 기본 거부: 일치하는 정책 규칙이 없는 패킷은 드롭됨
- 모든 정책 위반에 대한 감사 로깅(DoS 방지를 위한 속도 제한)

**암호화 요구사항**:
- Site-to-site 터널을 위한 WireGuard 또는 IPsec(사용자 공간이 아닌 커널 crypto API)
- eBPF 프로그램은 터널 헤더 검증; 복호화는 커널 서브시스템에서 처리
- eBPF 맵에 평문 정책 시크릿 금지(사용자 공간 보안 스토리지 + 맵 참조 사용)

## 개발 워크플로우 및 품질 게이트

**코드 리뷰**:
- eBPF 프로그램은 이중 검토 필요: (1) 기능적 정확성, (2) verifier 준수
- Rust 코드는 경고 없이 `cargo clippy` 통과 필요
- 보안에 민감한 변경사항은 위협 모델 업데이트 필요

**테스팅 게이트**:
- 단위 테스트: `cargo test`를 통한 Rust 로직 테스트(모킹된 eBPF 맵 상호작용)
- 통합 테스트: 테스트 커널 네임스페이스에 eBPF 프로그램 로드, 패킷 주입을 통한 실행
- 성능 테스트: 병합 전 지연 시간 벤치마크는 p99 임계값 통과 필요
- 커널 호환성: LTS 커널 버전에 대한 CI 매트릭스 테스트

**지속적 통합**:
- eBPF 프로그램은 `-Werror`로 컴파일(clang 경고를 오류로 처리)
- 실패한 로드에 대한 verifier 로그 보관
- 자동화된 `cargo audit` 및 `cargo deny` 검사
- 테스트 VM에서 BTF 가용성 검증

**관찰성**:
- Prometheus를 통한 메트릭 익스포트(패킷 수, 지연 시간 히스토그램, 정책 적중/미스)
- 제어 플레인 이벤트를 위한 구조화된 로깅(JSON)
- `bpftool prog show` 통합을 통한 eBPF 프로그램 통계
- 성능 디버깅을 위한 플레임 그래프(eBPF 프로그램에 `perf` 연결)

## 거버넌스

**개정 프로세스**:
- 헌장 변경은 문서화된 근거와 영향 분석 필요
- 파괴적 변경(예: CO-RE 요구사항 제거)은 MAJOR 버전 증가 및 마이그레이션 가이드 필요
- 추가적 변경(예: 새로운 보안 원칙)은 MINOR 버전 증가 사용

**준수 검증**:
- 모든 PR은 헌장 준수 체크리스트 포함 필요
- 새로운 기능을 위한 설계 문서는 특정 원칙에 매핑 필요
- 분기별 감사를 통해 기술 부채 위반 없음을 검증(예: unsafe Rust 사용)

**복잡도 정당화**:
- 원칙에서 벗어나는 경우(예: 복잡도 제한을 초과하는 eBPF 프로그램)는 다음이 필요:
  1. 더 간단한 대안이 실패하는 이유에 대한 서면 정당화
  2. verifier 승인 증명(또는 명시적 커널 버전 제한 문서화)
  3. 편차가 공격 표면에 영향을 미치는 경우 보안 검토

**버전**: 1.0.0 | **비준일**: 2025-10-07 | **최종 수정일**: 2025-10-07
