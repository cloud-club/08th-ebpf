# Week 2: BPF 데이터 타입 및 CO-RE, 데이터 당겨오는 원리 스터디

## BPF 데이터 타입

### 1. 기본 데이터 타입
BPF 프로그램에서 사용할 수 있는 기본 데이터 타입들:

- **스칼라 타입**: `u8`, `u16`, `u32`, `u64`, `s8`, `s16`, `s32`, `s64`
- **포인터 타입**: 커널 메모리 접근을 위한 안전한 포인터
- **BPF 맵 타입**: 커널-유저스페이스 간 데이터 공유를 위한 구조

### 2. BPF 맵 (Maps)
커널과 유저스페이스 간 데이터를 공유하는 핵심 메커니즘:

```c
// 맵 타입 예시
BPF_HASH(counts, u32, u64);        // 해시 맵
BPF_ARRAY(values, struct data, 10); // 배열 맵
BPF_PERF_OUTPUT(events);            // 성능 이벤트 출력
BPF_RINGBUF(rb, 1 << 20);          // 링 버퍼 (1MB)
```

**주요 맵 타입들:**
- `BPF_MAP_TYPE_HASH`: 키-값 저장소
- `BPF_MAP_TYPE_ARRAY`: 인덱스 기반 배열
- `BPF_MAP_TYPE_PERCPU_HASH`: CPU별 해시 맵
- `BPF_MAP_TYPE_PERF_EVENT_ARRAY`: 성능 이벤트 전달
- `BPF_MAP_TYPE_RINGBUF`: 스트리밍

### 3. 컨텍스트 구조체
각 BPF 프로그램 타입마다 고유한 컨텍스트 구조체를 받음:

```c
// kprobe 컨텍스트
struct pt_regs *ctx;

// tracepoint 컨텍스트
struct trace_event_raw_* *ctx;

// XDP 컨텍스트
struct xdp_md *ctx;

// socket filter 컨텍스트
struct __sk_buff *ctx;
```

## CO-RE (Compile Once - Run Everywhere)

### 1. CO-RE란?
- **문제점**: 커널 버전마다 구조체 레이아웃이 다름
- **해결책**: BTF(BPF Type Format)를 활용한 이식성 있는 BPF 프로그램
- **장점**: 한 번 컴파일로 여러 커널 버전에서 실행 가능

### 2. BTF (BPF Type Format)
커널 데이터 구조의 타입 정보를 제공:
> 이게 orbstack에서는 안받아지더라고요. 직접 생성이 필요하시면 EC2에서 해당 커맨드를 돌려도 되고, 아니면 제가 받아놓은 게 있어서 사용하시면 됩니다 (`projects/yhc/vmlinux.h`)
```c
// BTF 정보 확인
$ bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h

```

### 3. CO-RE 헬퍼 매크로

```c
#include <bpf/bpf_core_read.h>

// 구조체 필드 안전하게 읽기
struct task_struct *task;
pid_t pid = BPF_CORE_READ(task, pid);

// 필드 존재 여부 확인
if (bpf_core_field_exists(task->nsproxy))
    ns = BPF_CORE_READ(task, nsproxy);

// 필드 오프셋 가져오기
u32 offset = bpf_core_field_offset(struct task_struct, comm);
```

### 4. libbpf와 CO-RE
```c
// libbpf skeleton 사용
struct my_bpf *skel;
skel = my_bpf__open();
my_bpf__load(skel);
my_bpf__attach(skel);
```

## 데이터 당겨오는 원리

### 1. 커널 스페이스 → 유저 스페이스 데이터 전달 과정

```
[커널 스페이스]          [공유 메모리]           [유저 스페이스]
BPF 프로그램  ──────▶  BPF Maps/RingBuf  ◀────── 유저 애플리케이션
(데이터 수집)          (데이터 저장)            (데이터 읽기)
```

### 2. 데이터 수집 메커니즘

#### a) Probing (프로빙)
```c
// kprobe 예시: sys_open 호출 추적
SEC("kprobe/sys_open")
int trace_open(struct pt_regs *ctx) {
    char filename[256];
    bpf_probe_read_user_str(filename, sizeof(filename), 
                            (void *)PT_REGS_PARM1(ctx));
    // 맵에 저장
    bpf_map_update_elem(&open_files, &pid, &filename, BPF_ANY);
    return 0;
}
```

#### b) Tracepoint (트레이스포인트)
```c
// 스케줄러 이벤트 추적
SEC("tracepoint/sched/sched_switch")
int trace_switch(struct trace_event_raw_sched_switch *ctx) {
    u32 prev_pid = ctx->prev_pid;
    u32 next_pid = ctx->next_pid;
    // 데이터 처리
    return 0;
}
```

### 3. 헬퍼 함수를 통한 데이터 접근

**주요 헬퍼 함수들:**
```c
// 커널 메모리 읽기
bpf_probe_read_kernel(&dst, size, src);

// 유저 메모리 읽기
bpf_probe_read_user(&dst, size, src);

// 문자열 읽기
bpf_probe_read_kernel_str(dst, size, src);

// 현재 프로세스 정보
u64 pid_tgid = bpf_get_current_pid_tgid();
u64 uid_gid = bpf_get_current_uid_gid();
char comm[16];
bpf_get_current_comm(comm, sizeof(comm));
```

### 4. 데이터 전송 방식

#### a) Per-event (이벤트별 전송)
```c
// Perf Buffer 사용
struct event {
    u32 pid;
    char comm[16];
};

BPF_PERF_OUTPUT(events);

// 이벤트 전송
events.perf_submit(ctx, &event, sizeof(event));
```

#### b) Aggregation (집계)
```c
// HashMap으로 집계
BPF_HASH(counts, u32, u64);

// 카운트 증가
u64 *count = counts.lookup(&key);
if (count)
    (*count)++;
```

#### c) Ring Buffer (효율적인 스트리밍)
```c
// Ring Buffer로 대용량 데이터 전송
BPF_RINGBUF(rb, 1 << 20);  // 1MB

struct event *e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
if (e) {
    e->pid = pid;
    bpf_ringbuf_submit(e, 0);
}
```

### 5. 유저스페이스에서 데이터 읽기

#### Python BCC 예시:
```python
from bcc import BPF

# BPF 프로그램 로드
b = BPF(src_file="program.c")

# 맵 접근
counts = b["counts"]

# 이벤트 콜백
def print_event(cpu, data, size):
    event = b["events"].event(data)
    print(f"PID: {event.pid}, Command: {event.comm}")

# Perf Buffer 폴링
b["events"].open_perf_buffer(print_event)
while True:
    b.perf_buffer_poll()
```

#### libbpf 예시:
```c
// 맵 FD 가져오기
int map_fd = bpf_map__fd(skel->maps.counts);

// 맵 데이터 읽기
u32 key = 0;
u64 value;
bpf_map_lookup_elem(map_fd, &key, &value);

// Ring Buffer 폴링
ring_buffer__poll(rb, 100 /* timeout_ms */);
```

## 실습 예제: 시스템 콜 카운터

```c
// syscall_counter.c
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 256);
    __type(key, u32);
    __type(value, u64);
} syscall_counts SEC(".maps");

SEC("tracepoint/raw_syscalls/sys_enter")
int count_syscalls(struct trace_event_raw_sys_enter *ctx) {
    u32 syscall_id = ctx->id;
    u64 *count, init_val = 1;
    
    count = bpf_map_lookup_elem(&syscall_counts, &syscall_id);
    if (count) {
        __sync_fetch_and_add(count, 1);
    } else {
        bpf_map_update_elem(&syscall_counts, &syscall_id, 
                           &init_val, BPF_ANY);
    }
    
    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

## 핵심 포인트 정리

1. **BPF Maps**: 커널-유저스페이스 간 데이터 공유의 핵심
2. **CO-RE**: BTF를 활용한 이식성 있는 BPF 프로그램 작성
3. **헬퍼 함수**: 안전한 커널 데이터 접근을 위한 API
4. **데이터 전송**: Perf Buffer, Ring Buffer 등 용도에 맞는 선택
5. **성능 고려**: Per-CPU 맵, 배치 처리 등으로 오버헤드 최소화

## 참고 자료
- [BPF CO-RE Reference Guide](https://nakryiko.com/posts/bpf-portability-and-co-re/)
- [Linux Kernel BPF Documentation](https://www.kernel.org/doc/html/latest/bpf/)
- [libbpf Documentation](https://libbpf.readthedocs.io/)
- [BCC Python Developer Tutorial](https://github.com/iovisor/bcc/blob/master/docs/tutorial_bcc_python_developer.md)