# Week 4 - 김재훈

4주차에서는 eBPF를 학습하기 위한 프로젝트 설계를 수행했으며, 아래와 같이 프로젝트 핵심 목표를 설정한다.
Claude Code와 GitHub Spec kit의 조합으로 초기 PRD 작성을 진행했으며, 이를 통해 XDP, TC의 존재를 알게 된다.

XDP(eXpress Data Path)는 기존 네트워크 스택에서 packet을 캡슐화하고 푸는 과정에서 발생하는 오버헤드를 최소화한다.

이 오버헤드는 Link Layer -> Network Layer -> Protocol Layer -> Application Layer를 거칠 때마다 발생하는데,
실제 encapsulation/decapsulation 작업에 대한 오버헤드도 있고, 하드웨어(NIC 등)로 들어온 정보를 CPU가 처리할 수 있는 공간으로 복사하는 오버헤드도 존재한다.
해당 데이터 복사는 저기 선에서 끝나지 않고, 커널 영역에서 유저 영역으로 복사하는 오버헤드도 존재한다.

XDP는 위 과정에 개입해서 CPU가 네트워크 스택을 경유하는 위 과정을 처리하기 전에, NIC 드라이버가 DMA(직접 메모리 접근)를 통해 메모리에 저장한 패킷 데이터를 바로 읽는다.
NIC는 해당 메모리 복사가 완료되면 인터럽트를 통해 CPU에게 sk_buff 생성을 시작하라는 신호를 보낼 수 있는데, 해당 자료구조에는 패킷 데이터를 향하는 포인터 뿐만 아니라,
수많은 프로토콜 처리 정보와 상태 플래그 등을 포함하고 있어 무거움.

XDP는 패킷 데이터만 간략하게 보기 위한 xdp_buff를 생성해 XDP_DROP이나 XDP_TX 액션을 통해 폐기하거나 다른 곳으로 전송할 수 있음.
- DROP: DDoS 방지, 방화벽 제작 등에 활용 가능
- TX: L4 로드밸런서, 라우터 제작 등에 활용 가능
통과되어야 하는 패킷이면 XDP_PASS를 통해 원래의 과정대로 sk_buff를 생성하고 패킷을 처리함.

위 내용을 정리하고 나니 아래와 같은 내용들이 추가로 궁금해짐:
- XDP, TC 등은 eBPF를 통해 작성된 프로그램이니까 eBPF 기술을 직접 학습하는 목적으로는 부적절한지? 또는 이또한 eBPF의 구성요소 중 하나로 보고 학습의 대상으로 삼아야할지?
- XDP를 내가 언어화해서 정리한 것처럼 TC는 어떻게 이해해야 할지
- XDP_PASS 액션 케이스에 해당할 때 실제 정상 네트워크 처리 과정에 단순히 추가되는 것이 아닌지

첫번째 질문부터 찾아보면 XDP와 TC는 커널 내의 Hook으로, eBPF가 자바스크립트 런타임 엔진이라면 XDP나 TC는 onclick 이벤트 핸들러나 네트워크 인터셉터 API처럼,
엔진의 기능을 활용해 실제 커널 공간의 이벤트를 처리하는 핸들러 함수에 가까움.
따라서 eBPF를 학습한다고 할 때 XDP나 TC를 학습한다고 해서 방향성이 바뀌는 것은 아닐듯..?

- TC(Traffic Control)의 경우 커널 내 eBPF 훅 중 네트워크 관련 훅인 XDP와 연관되어 있으며, 우선순위상 XDP 다음으로 실행됨.
순서: NIC -> XDP(eBPF) -> TC(eBPF) -> Connection Tracking(eBPF) -> TCP Stack -> Socket Layer

- 위 순서에 따라 TC는 XDP보다 느릴 수 있지만 커널 스페이스에 생성된 sk_buff 구조체를 다룸.
XDP에서 불가능한 트래픽에 대한 컨트롤을 보다 세심하게 할 수 있고, XDP는 xdp offloading을 지원하지 않는 NIC의 경우 오히려 성능 저하가 발생하기 때문에,
TC 단계에서 모든 트래픽 제어를 할 수도 있음(Cilium이 이런 방식)
XDP처럼 특정한 기술이 존재하기보단 커널에서 읽어올 수 있는 네트워크 트래픽을 읽고, 쓰는 모든 ebpf call을 TC로 볼 수 있음(Connection Tracking 관련 함수 제외)

- XDP_PASS 비용에 대한 부분은 xdp 기능이 지원되는 nic를 사용한다는 가정 하에 무시할 수 있는 비용이기도 하고,
내 프로젝트 목적에 맞게 동적으로 정책이 변경되는 지능형 방화벽 기능이 포함된 VPN Router를 만드는 경우 사전에 drop, tx를 처리함으로 얻는 이점이 훨씬 큼

해당 단계에서 추가로 생기는 궁금증이 있으며 해당 내용은 5주차에서 정리할 예정:
- tc ingress/egress hook은 eBPF 공식 문서에서 관련 concept나 함수를 찾을 수 없던데 어떤 내용인지
- TC에 대해 정리한 내용 중 잘못된 내용이 있는지



---

아래는 AI가 나의 작업 내용을 읽고 자동으로 요약해준 내용

**프로젝트 핵심 목표**:
- eBPF(XDP/TC)를 활용한 고성능 패킷 처리
- IDP(OIDC/SAML)와 통합한 동적 인증 시스템
- 실시간 정책 적용 및 감사 로깅
- 커스텀 VPN 프로토콜 구현

**기술 스택**:
- **언어**: Rust (사용자 공간), C (eBPF 프로그램)
- **eBPF 훅**: XDP (네트워크 인터페이스), TC (트래픽 제어)
- **데이터 구조**: eBPF Maps (LPM Trie, Hash, Ringbuffer)
- **VPN 프로토콜**: 커스텀 구현 (ChaCha20-Poly1305)
- **IDP 프로토콜**: OIDC/SAML 2.0

---

## 핵심 아키텍처 설계

### 1. 이중 플레인 아키텍처

프로젝트는 데이터 플레인과 제어 플레인을 명확하게 분리하는 아키텍처를 채택했습니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    데이터 플레인 (커널)                       │
├─────────────────────────────────────────────────────────────┤
│  XDP 프로그램 (인그레스)         TC 프로그램 (이그레스/VPN)   │
│  - 고속 경로 포워딩              - 복호화 후 RBAC 검사        │
│  - 조기 드롭                     - 정책 강제                 │
│  - 패킷 분류                     - 감사 로깅 트리거           │
└──────────────────┬──────────────────────────┬───────────────┘
                   │      eBPF 맵              │
                   │  (통신 브릿지)            │
┌──────────────────┴──────────────────────────┴───────────────┐
│                 제어 플레인 (사용자 공간)                     │
├─────────────────────────────────────────────────────────────┤
│  Rust 데몬                                                   │
│  - IDP 통합 (OIDC/SAML)                                     │
│  - 정책 컴파일 (IP→역할, 역할→ACL)                          │
│  - 맵 관리 (원자적 업데이트)                                │
│  - 원격 측정 집계 (ringbuffer 소비자)                       │
│  - VPN 터널 키 교환                                         │
└─────────────────────────────────────────────────────────────┘
```

**분리의 이점**:
- **성능**: 커널 공간 패킷 처리로 10μs 이하 지연시간(p99) 달성
- **격리**: 제어 플레인 크래시가 패킷 포워딩에 영향 없음
- **확장성**: 사용자 공간 개입 없이 초당 수백만 패킷 처리

### 2. 이중 훅 전략 (XDP + TC)

패킷 처리 파이프라인에서 XDP와 TC를 전략적으로 활용합니다.

**XDP (외부 인터페이스)**:
- NIC 드라이버 레벨에서 동작 (가장 빠른 훅 지점)
- 고속 포워딩 결정에 이상적
- 비용이 많이 드는 처리 전에 악의적 패킷 조기 드롭
- 액션: `XDP_DROP`, `XDP_PASS`, `XDP_TX`

**TC (VPN 인터페이스)**:
- L3 복호화 이후 동작 (내부 IP 헤더 접근 가능)
- 복호화된 트래픽에 대한 RBAC 강제
- 세부 정책 매칭을 위한 전체 패킷 컨텍스트 접근
- 액션: `TC_ACT_OK` (통과), `TC_ACT_SHOT` (드롭)

**패킷 플로우**:
```
외부 패킷 → NIC → XDP 프로그램 → 네트워크 스택 → VPN 복호화
                      ↓
                  (고속 드롭)

복호화된 패킷 → TC 프로그램 → RBAC 검사 → 포워드/드롭 → 이그레스
                    ↓
              (정책 강제)
```

### 3. Rust 사용자 공간 제어 플레인

**선택 이유**:
- **메모리 안전성**: 전체 클래스의 CVE 제거
- **제로 비용 추상화**: C와 동등한 성능
- **생태계**:
  - `aya`: 순수 Rust eBPF 라이브러리
  - `tokio`: 비동기 런타임
  - `openidconnect`: IDP 통합용

**Unsafe 정책**:
- FFI 경계 (시스템콜, ioctl)에만 허용
- 모든 `unsafe` 사용은 안전 주석 필수
- 두 번째 엔지니어의 코드 리뷰 필수

---

## 결론

4주차 학습을 통해 eBPF의 기초 개념에서 프로덕션급 시스템 설계까지 진전을 이루었습니다.

**핵심 성과**:
- 120개 구현 태스크로 분해된 상세한 프로젝트 계획
- 성능과 보안을 고려한 아키텍처 설계
- eBPF 맵, Verifier, CO-RE 등 핵심 개념의 실전 적용
- IDP 통합 등 현대적 인증 시스템과의 통합 방안

다음 단계에서는 설계한 내용을 실제로 구현하며, eBPF 프로그래밍의 실전 경험을 쌓을 예정입니다.
